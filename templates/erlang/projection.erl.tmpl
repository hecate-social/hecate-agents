%%% Projection: {{event}}_v1 -> {{read_store}} table
%%% Domain: query_{{aggregates}}

-module({{event}}_to_{{read_store}}).
-behaviour(gen_server).

-export([start_link/0]).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2]).

-include_lib("kernel/include/logger.hrl").

%%====================================================================
%% API
%%====================================================================

start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

%%====================================================================
%% gen_server callbacks
%%====================================================================

init([]) ->
    ok = reckon_evoq:subscribe({{cmd_domain}}_store, self(), #{
        event_types => [<<"{{event}}_v1">>]
    }),
    ?LOG_INFO("[~s] Projection started", [?MODULE]),
    {ok, #{}}.

handle_call(_Request, _From, State) ->
    {reply, {error, not_implemented}, State}.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info({evoq_event, _StreamId, EventType, EventData, Position}, State)
  when EventType =:= <<"{{event}}_v1">> ->
    ok = project(EventData),
    ok = reckon_evoq:ack({{cmd_domain}}_store, Position),
    {noreply, State};

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

%%====================================================================
%% Internal
%%====================================================================

project(EventData) ->
    Row = #{
        {{aggregate}}_id => maps:get(<<"{{aggregate}}_id">>, EventData),
        %% TODO: add fields from event schema
        updated_at => erlang:system_time(millisecond)
    },
    query_{{aggregates}}_store:upsert({{read_store}}, Row).
